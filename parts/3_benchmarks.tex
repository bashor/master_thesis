\section{Тесты производительности}

% Прежде чем пытаться улучшить имеющейся код, необходимо выработать критерии, по которым мы сможем проверить насколько успешными были наши улучшения. Наличие независимых критериев для разных характеристик позволит нам наглядно видеть как текущие изменения влияют на интересующие нас характеристики, тем самым позволив вовремя заметить и отреагировать на ухудшение других характеристик, в результате наших изменений.
% В качестве таких критериев обычно используют тесты производительности. Кроме того, эти тесты могут помочь при поиске <<узких мест>>.

% Ни один современный проект по разработке виртуальной машины JavaScript не обходится без тестов производительности(benchmarks). В этих проектах в основном используются два типа тестов. Первый тип это так называемые <<микро-бенчмарки>> -- это тесты созданные для измерения отдельных маленьких частей системы. Ярким примером является набор тестов от разработчиков из Mozilla -- Dromaeo \cite{Dromaeo}.  Другой тип используемых тестов, который часто называют <<макро-бенчмарками>> -- это <<реальные>> программы, либо имитирующие их поведение. Ярыми приверженцами такого похода являются разработчики виртуальной машины V8, использующейся в Chrome \cite{V8:Benchmarks, Octane}. Все эти тесты находятся в открытом доступе и разработчики проверяют результаты своей работы также и на тестах конкурентов.

В рамках данной работы для реализации тестов производительности было решено взять за основу тесты Richards и DeltaBlue из набора тестов, используемых командой V8 \cite{V8:Benchmarks}. Так же в значительной мере на выбор повлиял тот факт, что данные тесты являются основными в проекте Dart.
Кроме этих двух тестов, было решено реализовать тест производительности Havlak \cite{Havlak}, разработанный в компании Google для сравнения таких языков как C++, Java, Go и Scala.

Такой выбор тестов позволил исключить предвзятость при реализации тестов производительности на других языках, т.к. для сравнения с другими языками используются проверенные годами и написанные специалистами тесты. К тому же, все эти тесты находятся в открытом доступе и любой желающий сможет повторить приведенные в данной работе эксперименты \cite{v8:bench:src, dart:bench:src, kotlin:bench:src}.

\subsection{Тест производительности Richards}

% Это тест спроектированный для сравнения различных языков и их различных компиляторов. Тест не 
Оригинальная версия теста была написана Мартином Ричардсом в 1999 году на языке программирования BCPL. В данном тесте симулируется работа ядра операционной системы.
Основным фокус данного тест -- это проверка скорости чтения и записи данных, а так же проверка скорости вызова функций и методов. Кроме того, тест позволяет проверить на сколько хорошо реализованы оптимизация кода и устранение избыточного кода в проверяемой системе \cite{Richards}.

\subsection{Тест производительности DeltaBlue}

DeltaBlue -- это односторонний constraint solver написанный Джоном Малони и Марио Волчко начале 90х. Изначально был написан на языке Smalltalk, позднее был переписан на множество языков. Данный алгоритм часто используется в качестве теста производительности для проверки реализации полиморфизма в языке. Так же, для языков с автоматическим управлением памятью данный тест позволяет протестировать эффективность работы сборщика мусора, поскольку алгоритм предполагает создание большого количества, в основном недолго живущих, объектов \cite{DeltaBlueST, DeltaBlue, DeltaBlue2}.

\subsection{Тест производительности Havlak}

В данном тесте используется алгоритм поиска и преобразования циклов описанный в статье Паула Хавлака ”Nesting of reducible and irreducible
loops” \cite{Havlak}. Тест был разработан в компании Google для сравнения таких языков как C++, Java, Go и Scala по таким критериям как: время выполнения теста, объем кода, размер программы после компиляции, объем памяти используемой во время работы теста \cite{HavlakBench}. Позже разработчики из компании Google так же реализовали данный тест и на многих других языках, например на Dart и JavaScript. Данный тест хорошо подходит для проверки использующихся в языке контейнеров. Кроме того, данный тест позволяет проверить на сколько хорошо в языке реализован контроль за ресурсами и на сколько хорошо работает сборщик мусора.

