\chapter{Тесты производительности}

Прежде чем пытаться улучшить имеющейся код было бы не плохо выработать критерии по которым мы сможем проверить на сколько успешными были наши улучшения. Наличие независимых критериев для разных характеристик позволит нам наглядно видеть как текущие изменения влияют на интересующие нас характеристики. Тем самым, позволив вовремя заметить и отреагировать на ухудшение других характеристик, в результате наших изменений.
В качестве таких критериев обычно используют тесты производительности. Кроме того, эти тесты могут помочь при поиске <<узких мест>>.

Ни один современный проект по разработке JavaScript виртуальной машины не обходится без тестов производительности. В этих проектах в основном используются два типа тестов. Первый тип это так называемые <<микро-бенчмарки>> -- это тесты созданные для измерения отдельных маленьких частей системы. Ярким примером таких тестов является набор тестов от разработчиков из Mozilla -- Dromaeo \cite{Dromaeo}.  Другой тип используемых тестов, который часто называют <<макро-бенчмарками>> -- это <<реальные>> программы, либо программы имитирующие поведение <<реальных>> программ. Ярыми приверженцами такого похода являются разработчики, использующейся в Chrome, виртуальной машины V8 \cite{V8:Benchmarks, Octane}. Все эти тесты находятся в открытом доступе и разработчики проверяют результаты свой работы так же и на тестах конкурентов.

В рамках данной работы для реализации тестов производительность было решено взять за основу тесты Richards и DeltaBlue, которые из набора тестов используемого командой V8 \cite{V8:Benchmarks}. Так же в значительной мере на выбор повлиял тот факт, что данные тесты являются основными в проекте Dart.
Кроме этих двух тестов было решено реализовать тест производительности Havlak, разработанный в компании Google для сравнения таких языков как C++, Java, Go и Scala.
Такой выбор тестов позволил исключить предвзятость при реализации тестов производительности на других языках, т.к. для сравнения с другими языками используются проверенные годами и написанные специалистами тесты. К тому же, все эти тесты находятся в открытом доступе и любой желающий сможет повторить приведенные в данной работе эксперименты.

\section{Тест производительности Richards}

Этот тест был написан для сравнения различных языков и различных их реализаций на . Тест не
Оригинальная версия теста была написана Мартином ричардсом в 1999 году на языке программирования BCPL. В данном тесте симулируется работа ядра операционной системы.
Основным фокус данного тест это проверка скорости чтения и записи данных, а так же проверка скорости вызова функций и методов. Кроме того, тест позволяет проверить на сколько хорошо реализованы оптимизация кода и устранение избыточного кода в проверяемой системе.
\cite{Richards}

\section{Тест производительности DeltaBlue}

DeltaBlue -- это односторонний constraint solver написанный Джоном Малони и Марио Волчко начале 90х. Изначально был написан на языке Smalltalk, позднее был переписан на множество языков. Данный алгоритм часто используется в качестве теста производительности для проверки реализации полиморфизма в языке. Так же, для языков с автоматическим управлением памятью данный тест позволяет протестировать эффективность работы сборщика мусора. Этому способствует тот факт, что алгоритм предполагает создание большого количества, в основном, недолго живущих объектов.
\cite{DeltaBlueST, DeltaBlue, DeltaBlue2}

\section{Тест производительности Havlak}

В данном тесте используется алгоритм поиска и преобразования циклов описанный в статье Паула Хавлака ”Nesting of reducible and irreducible
loops”. \cite{Havlak} Тест был разработан в компании Google для сравнения таких языков как C++, Java, Go и Scala по таким критериям как: время выполнения теста, объем кода, размер программы после компиляции, объем памяти используемой во время работы теста \cite{HavlakBench}. Позже разработчики из компании Google так же реализовали данный тест и на многих других языках, например на Dart и JavaScript. Данный тест хорошо подходит для проверки использующихся в языке контейнеров. Кроме того, данный тест позволяет проверить на сколько хорошо в языке реализован контроль за ресурсами и на сколько хорошо работает сборщик мусора.

