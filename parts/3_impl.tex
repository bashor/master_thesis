\chapter{Реализация}

\section{Выбор языков для сравнения}

хочется не только понимать что мы улучшились хочется и посмотреть как мы выглядим на фоне остальных

С кем сравниваемся?

JavaScript (бенчмарки от разработчиков v8)
Dart (бенчмарки от разработчиков)
Dart2js

Google Web Toolkit
в паблике тестов производительности нет

Dart -- есть

CoffeeScript и TypeScript нет, во многом это объясняется тем, что эти языки не сильно отличаются от JS ??? у них нету кросс библиотек которые нужно поддерживать на разных платформах. Система типов либо вообще не отличается либо незначительно. Более просетое наследование.

Сравниваться со всем кончено получилось бы и пришлось выбрать нескольких.
Почему именно эти аналоги?
Ну во первых это реализация на чистом JS, были взяты тесты от разработчиков v8. Я считаю это обязательным пунктом, чтобы показать, понять на сколько мы хуже чем код написанный вручную на целевом языке.(тем более экспертами) И сделать выводы в чем мы хуже и почему, что можно улучшить. А в итого показать на сколько мы хуже или лучше чем такой код.

Казалось бы что может быть лучше вручную написанного JS кода? Я решил немного повысить планку и взять Dart, особенность в том, что дарт спроектирован с учетом некоторых недостатков JS, язык разрабоатывается практически той же коммандой которая разрабатывает v8, нативная реализация дарта выполняется в своей виртуальной машине которая знает о коде чуть больше и очень активно пользуется этим, за счет чего на многих тестах уже сейчас показывает лучшие результаты чем вручную написанный JS

Ну и планачка чуть по ниже это js полученный путем трансляции дарт в js

ТО план минимум работать так же хорошо как dart2js, план максимум работать так же хорошо как dart(видимо не всегда достижимый)



\section{Тесты производительности}

Прежде чем начинать пытаться что-то улучшить нужно вырабатать критерии по которым мы сможем проверить на сколько успешными были наши улучшения. А наличие независимых критериев для разных характеристик позволит намнаглядно видить как текйщие изменения влияют на интересуещие нас характеристики. Тем самым, позволив вовремя заметить и отреагировать на ухудшение других характеристик, в результате наших изменений.
В качестве таких критериев обычно выступают тесты производительности. Кроме того, такие тесты могут помочь в поиске <<узких мест>>.

Ни один современный проект по разработке JavaScript виртуальной машины не обходится без тестов производтиельности. В этих проектах в основном используются два типа тестов. Первый тип это так называемые <<микро-бенчмарки>> -- это тесты созданные для измерения отдельных маленьких частей системы. Ярким пример омтаких тестов является набор тестов от разработчиков из Mozilla -- Dromaeo \cite{Dromaeo}  Другой тип используемых тестов, который часто называют <<макро-бенчмарками>> -- это <<реальные>> программы, либо программы имитирующие поведение <<реальных>> программ. Ярыми привереженцами такого похода являются разработчки использующейся в Chrome вритуальной машины V8 \cite{V8:Benchmarks, Octane}. Все эти тесты находятся в открытом доступе и разработчки проверяют результаты свой работы так же и на тестах кокурентов.

В рамках данной работы для реализации тестов производительность было решено взять за основу тесты Richards и DeltaBlue, которые из набора тестов используемого коммандой V8 \cite{V8:Benchmarks}. Так же в значительной мере на выбор повлиял тот факт что данные тесты являются основными в проекте Dart.
Кроме этих двух тестов было решено реализовать тест производительности Havlak, разработанный в компании Google для сравнения таких языков как C++, Java, Go и Scala по таким критериям как: время выполнения теста, объем кода, размер программы после компиляции, объем памяти используемой во время работы теста \cite{HavlakBench}. Позже разработчики из компании Google так же реализовали данный тест и на многих других языках, например на Dart и JavaScript.
Такой выбор тестов позволил исключить предвзятость при реализации тестов производительности на других языках, т.к. для сравнения с другими языками используются проверенные годами и написанные специалистами тесты. К тому же, все эти тесты находятся в открытом доступе и любой желающий сможет повторить приведенные в данной работе эксперименты.

\subsection{Тест производительности Richards}

Этот тест был написан для сравнения различных языков и различных их реализаций на . Тест не
Оригинальная версия теста была написана Мартином ричардсом в 1999 году на языке программирования BCPL. В данном тесте симулируется работа ядра операционной системы.
Тест фокусируется на проверки скорости чтения и записа данных, а так же на проверке скорости вызова функций и методов. Как и у многих тестов, данный тест имеет вторичный фокус -- оптимизация кода и устраниние избыточного кода.
\cite{Richards}

\subsection{Тест производительности DeltaBlue}

DeltaBlue -- это односторонний constraint solver написанный Джоном Малони и Марио Волчко начале 90х. Изначально был написан на языке Smalltalk, позднее был переписан на множество языков. Данный алгоритм часто используется в качестве теста производительности для проверки реализации полиморфизма в языке. Так же, для языков с автоматическим управлением памятью данный тест позволяет протестировать эффективность работы сборщика мусора. Этому способствует то что алгоритм предполагает создание большого количества, в основном, недолго живущих объектов.
\cite{DeltaBlueST, DeltaBlue, DeltaBlue2}

\subsection{Тест производительности Havlak}

В данном тесте используется алгоритм поиска и преобразования циклов описанный в статье Паула Хавлака ”Nesting of reducible and irreducible
loops”. \cite{Havlak} Тест был разработан в компании Google для сравнения таких языков как C++, Java, Go и Scala по таким критериям как: время выполнения теста, объем кода, размер программы после компиляции, объем памяти используемой во время работы теста \cite{HavlakBench}. Позже разработчики из компании Google так же реализовали данный тест и на многих других языках, например на Dart и JavaScript. Данный тест хорошо подходит для проверки использующихся в языке контейнеров. Кроме того, данный тест позволяет проверить на сколько хорошо в языке реализован контроль за ресурсами и на сколько хорошо работает сборщик мусора.

\section{Тестирование и анализ результатов}

\subsection{Методика тестирования}

\subsection{Richards}
---
Richards: Выводы

Оптимизировать доступ к полям/свойствам, по возможности, сохранив бинарную совместимость
Сделать аналог импорта, предоставив тем самым возможность кратко обращаться к объектам и их полям
Необходимо упростить структуру генерируемого кода

\subsection{DeltaBlue}

---
<<Прямой>> вызов конструкторов
---
DeltaBlue: Выводы

Заменить все контейнеры на родные для JS аналоги
Генерировать чистое прототипное наследование без оберток
Инициализировать все поля класса в конструкторе
Инициализировать все поля класса в одном порядке
Заменить или оптимизировать Kotllin.equals

\subsection{Havlak}
\section {Реализация оптимизаций}