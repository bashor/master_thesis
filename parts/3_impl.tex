\chapter{Реализация}

\section{Выбор языков для сравнения}

хочется не только понимать что мы улучшились хочется и посмотреть как мы выглядим на фоне остальных

С кем сравниваемся?

JavaScript (бенчмарки от разработчиков v8)
Dart (бенчмарки от разработчиков)
Dart2js

Google Web Toolkit
в паблике тестов производительности нет

Dart -- есть

CoffeeScript и TypeScript нет, во многом это объясняется тем, что эти языки не сильно отличаются от JS ??? у них нету кросс библиотек которые нужно поддерживать на разных платформах. Система типов либо вообще не отличается либо незначительно. Более просетое наследование.

Сравниваться со всем кончено получилось бы и пришлось выбрать нескольких.
Почему именно эти аналоги?
Ну во первых это реализация на чистом JS, были взяты тесты от разработчиков v8. Я считаю это обязательным пунктом, чтобы показать, понять на сколько мы хуже чем код написанный вручную на целевом языке.(тем более экспертами) И сделать выводы в чем мы хуже и почему, что можно улучшить. А в итого показать на сколько мы хуже или лучше чем такой код.

Казалось бы что может быть лучше вручную написанного JS кода? Я решил немного повысить планку и взять Dart, особенность в том, что дарт спроектирован с учетом некоторых недостатков JS, язык разрабоатывается практически той же коммандой которая разрабатывает v8, нативная реализация дарта выполняется в своей виртуальной машине которая знает о коде чуть больше и очень активно пользуется этим, за счет чего на многих тестах уже сейчас показывает лучшие результаты чем вручную написанный JS

Ну и планачка чуть по ниже это js полученный путем трансляции дарт в js

ТО план минимум работать так же хорошо как dart2js, план максимум работать так же хорошо как dart(видимо не всегда достижимый)



\section{Тесты производительности}

Прежде чем начинать пытаться что-то улучшить нужно вырабатать критерии по которым мы сможем проверить на сколько успешными были наши улучшения. А наличие независимых критериев для разных характеристик позволит намнаглядно видить как текйщие изменения влияют на интересуещие нас характеристики. Тем самым, позволив вовремя заметить и отреагировать на ухудшение других характеристик, в результате наших изменений.
В качестве таких критериев обычно выступают тесты производительности. Кроме того, такие тесты могут помочь в поиске <<узких мест>>.

Ни один современный проект по разработке JavaScript виртуальной машины не обходится без тестов производтиельности. В этих проектах в основном используются два типа тестов. Первый тип это так называемые <<микро-бенчмарки>> -- это тесты созданные для измерения отдельных маленьких частей системы. Ярким пример омтаких тестов является набор тестов от разработчиков из Mozilla -- Dromaeo \cite{Dromaeo}  Другой тип используемых тестов, который часто называют <<макро-бенчмарками>> -- это <<реальные>> программы, либо программы имитирующие поведение <<реальных>> программ. Ярыми привереженцами такого похода являются разработчки использующейся в Chrome вритуальной машины V8 \cite{V8:Benchmarks, Octane}. Все эти тесты находятся в открытом доступе и разработчки проверяют результаты свой работы так же и на тестах кокурентов.

В рамках данной работы для реализации тестов производительность было решено взять за основу тесты Richards и DeltaBlue, которые из набора тестов используемого коммандой V8 \cite{V8:Benchmarks}. Так же в значительной мере на выбор повлиял тот факт что данные тесты являются основными в проекте Dart.
Кроме этих двух тестов было решено реализовать тест производительности Havlak, разработанный в компании Google для сравнения таких языков как C++, Java, Go и Scala по таким критериям как: время выполнения теста, объем кода, размер программы после компиляции, объем памяти используемой во время работы теста \cite{HavlakBench}. Позже разработчики из компании Google так же реализовали данный тест и на многих других языках, например на Dart и JavaScript.
Такой выбор тестов позволил исключить предвзятость при реализации тестов производительности на других языках, т.к. для сравнения с другими языками используются проверенные годами и написанные специалистами тесты. К тому же, все эти тесты находятся в открытом доступе и любой желающий сможет повторить приведенные в данной работе эксперименты.

\subsection{Тест производительности Richards}

Этот тест был написан для сравнения различных языков и различных их реализаций на . Тест не
Оригинальная версия теста была написана Мартином ричардсом в 1999 году на языке программирования BCPL. В данном тесте симулируется работа ядра операционной системы.
Тест фокусируется на проверки скорости чтения и записа данных, а так же на проверке скорости вызова функций и методов. Как и у многих тестов, данный тест имеет вторичный фокус -- оптимизация кода и устраниние избыточного кода.
\cite{Richards}

\subsection{Тест производительности DeltaBlue}

DeltaBlue -- это односторонний constraint solver написанный Джоном Малони и Марио Волчко начале 90х. Изначально был написан на языке Smalltalk, позднее был переписан на множество языков. Данный алгоритм часто используется в качестве теста производительности для проверки реализации полиморфизма в языке. Так же, для языков с автоматическим управлением памятью данный тест позволяет протестировать эффективность работы сборщика мусора. Этому способствует то что алгоритм предполагает создание большого количества, в основном, недолго живущих объектов.
\cite{DeltaBlueST, DeltaBlue, DeltaBlue2}

\subsection{Тест производительности Havlak}

В данном тесте используется алгоритм поиска и преобразования циклов описанный в статье Паула Хавлака ”Nesting of reducible and irreducible
loops”. \cite{Havlak} Тест был разработан в компании Google для сравнения таких языков как C++, Java, Go и Scala по таким критериям как: время выполнения теста, объем кода, размер программы после компиляции, объем памяти используемой во время работы теста \cite{HavlakBench}. Позже разработчики из компании Google так же реализовали данный тест и на многих других языках, например на Dart и JavaScript. Данный тест хорошо подходит для проверки использующихся в языке контейнеров. Кроме того, данный тест позволяет проверить на сколько хорошо в языке реализован контроль за ресурсами и на сколько хорошо работает сборщик мусора.

\section{Тестирование и анализ результатов}

\subsection{Методика тестирования}

Запуск тестов производилось на компьютере со следующими характеристиками:
\begin{itemize}
\item Процессор: Intel(R) Core(TM)2 CPU 6400 с частотой 2.13 GHz.
\item Размер оперативной памяти: 4 гб.
\item Операционная система: Ubuntu 12.10 64-bit.
\end{itemize}

Для запуска JavaScript кода, в том числе сгенерированного компиляторами Kotlin и Dart2js, использовались виртуальные машины V8 и SpiderMonkey 17 (mozjs17). При запуске тестов с использованием SpiderMonkey использовался следующий набор ключей: <<\path$--methodjit$ \path$--typeinfer$>>. Первый параметр включает JIT компиляции методов с помощью JaegerMonkey, второй -- включает сбор информации о типах переменных и дальнейшее использования этой информации для оптимизаций.
Для запуска тестов на языке Dart использовалась виртуальная машина DartVM. Виртуальная машина языка Dart и компилятор Dart2js были взяты из dart-sdk версии 0.4.2.8.


Каждое измерение состоит из двух основных этапов, каждый длительностью в 2 секунды. В качестве результата берутся только результаты второго запуска, а первый запуск нужен для того что бы дождаться пока виртуальная машина перейдет в стабильное состояние. Так же, на этом этапе осуществляется так называемый <<прогрев>> виртуальной машины. Для <<прогрев>> виртуальной машины на нем запускается код теста. Данная процедура, позволяет виртуальной машине собрать необходимую информацию о коде, что бы провести оптимизации и выполнять тест максимально быстро на втором этапе.
В время основного запуска измеряется количество успешных итераций запущенных в течении двух секунд и то сколько реально времени на это было потрачено. 
В конце каждой итерации выполняется проверка результатов и в случае если они не соответствуют эталонному значению тестирование экстренно завершается. Результатом работы теста является среднее время выполнения одной итерации.

\subsection{Richards}

Результаты, полученные на начальном этапе, когда еще не были сделаны никакие оптимизации, на тест Richards представленны на рисунке \ref{richards_0}.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.8\textwidth]{images/richards_0.png}
\caption{Результаты теста Richards без оптимизаций}
\label{richards_0}
\end{figure}

Из данной диаграммы видно, что при запуске на виртуaльной машине V8 тест скомпилированный с помощью компилятора Kotlin уступает тесту скомпилированному с помощью Dart2js примерно в 4 раза, тесту написанном на JavaScripte -- более чем в 5 раз. При запуске на mozjs17 эта разница при сравнении с тестом написанном JavaScript увеличивается до примерно 15 раз и в случае с Dart2js уменьшается до 2 раза. Безусловным лидером данного теста является код написанный на Dart и запущенный в DartVM.

Если открыть код получившейся в результате компиляции с помощью компилятора Kotlin не трудно заметить, что все обращения даже внутри пакета осуществляются по полному имени (см. листинг \ref{example_with_package}). Такого рода обращений в получившемся коде очень много и в случае большой вложенности пакетов это может отрицательно сказаться на результаты. 

Эксперименты подтвердили, что для виртуальной машины V8 это действительно так -- код в котором нет такой большой вложенности пакетов выполняется на 30\% быстрее. А для виртуальной машины mozjs17 такое изменение никакого влияния на производительность не оказало(см. рисунок \ref{richards_i}).


\begin{code}
\begin{lstlisting}[caption=Пример код с обращением по полному имени внутри того же пакета, label=example_with_package]
...
_ = {
org: Kotlin.definePackage({
  jetbrains: Kotlin.definePackage({
    kotlin: Kotlin.definePackage({
      benchmarks: Kotlin.definePackage({
        Richards_from_darts: Kotlin.definePackage({
          js: Kotlin.definePackage({
            ...
            addIdleTask: function (id, priority, queue, count) {
            this.addRunningTask(id, priority, queue, new _.org.jetbrains.kotlin.benchmarks.Richards.js.IdleTask(this, 1, count));
            }
            ...
\end{lstlisting}
\end{code}

Далее, можно заметить что все обращения к полям классов реализованы через функции обычно называемые <<аксессорами>>. Это объясняется тем, что в языке Kotlin у объектов нет полей, есть только свойства. По-умолчанию свойства имеют простую реализацию <<аксессоров>>, но пользователь может написать свою функцию <<аксессор>>. Для единообразия кода и для <<бинайрной>>\footnote{Под <<бинарной>> совместимостью понимается возможность изменять кода без необходимости перекомпилировать зависящие от него части}
совместимости компилятор все <<аксессоры>> транслирует в функции, а их доступ к ним -- в вызов соответствующих функций. Конечно же, современные виртуальные машины умеют подобного рода код встраивать в место вызова. Эксперименты подтвердили что многие <<аксессоры>> действительно встраиваются, но не все, например это может случиться если виртуальная машина посчитает, что данная функция не достаточно часто вызывается чтобы его встраивать или если  метод вызывается из многих мест компилятор может решить что встраивать в места всех вызовов слишком дорого. 
Полное встраивание <<акссесоров>> не осуществил и статический компилятор Closure-compiler. На рисунке \ref{richards_i} можно видеть как Closure-compiler повлиял на результат.
Далее был проведен эксперимент с полным встраиванием кода, что дало существенный выигрыш. Таким образом, при помощи несложных модификаций удалось получить почти четырехкратное ускорение. 

\begin{figure}[ht!]
\centering
	\begin{subfigure}[b]{0.7\textwidth}
	\centering
	\includegraphics[width=\textwidth]{images/richards_i_v8.png}
	\caption{Результаты измерений на V8}
    \end{subfigure}

  	\begin{subfigure}[b]{0.7\textwidth}
	\centering
	\includegraphics[width=\textwidth]{images/richards_i_mozjs17.png}
	\caption{Результаты измерений на mozjs17}
    \end{subfigure}
\\*``+'' означает что изменения накладываются на предыдущее
\caption{Оптимизация кода сгенерированного на тесте Richards}
\label{richards_i}
\end{figure}

% \subsubsection{Выводы}
\null
\begin{LARGE}
\begin{center}
\textbf{Выводы}
\end{center}
\end{LARGE}

В результате исследования кода, полученного после компиляции теста Richards, были сделаны следующие выводы:
\begin{itemize}
\item Необходимо упростить обращения внутри пакета.
\item Необходимо сделать аналог импортов, предоставив тем самым возможность кратко обращаться к объектам и их полям из других пакетов.
\item Необходимо оптимизировать доступ к свойствам, по возможности, <<сохранив>> бинарную совместимость.
\item Необходимо упростить структуру генерируемого кода.
\end{itemize}

\subsection{DeltaBlue}

Результаты, полученные на начальном этапе, когда еще не были сделаны никакие оптимизации, на тест Richards представленны на рисунке \ref{deltablue_0}.

\begin{figure}[ht!]
\centering
\includegraphics[width=0.8\textwidth]{images/deltablue_0.png}
\caption{Результаты теста DeltaBlue без оптимизаций}
\label{deltablue_0}
\end{figure}

При запуске на виртуaльной машине V8 тест скомпилированный с помощью компилятора Kotlin уступает ближайшему сопернику -- тесту скомпилированному с помощью Dart2js на 2 порядка. При запуске на mozjs17 на порядок медленне чем ближайший конкурент Dart2js.

На рисунке \ref{deltablue_i} можно видеть результат проведенных экспериментов. В первую очередь была были сделаны те же изменения что и для теста Richards -- это дало ускорение в среднем на 30\%, но на все равно разница с конкурентами все ещё достаточно большая, поэтому эксперименты были продолжены. Ощутимое ускорение удалось получить в следствии замены везде ArrayList на LinkedList.
Как видно из диаграмм небольшой выигрыш так же можно получить заменив все контейнеры на массивы. С помощью профилировщика встроенного в V8 удалось понять, что много времени тратится на конструирование объектов, причем существенную долю этого времени занимает работа инфраструктурного кода. Далее, как можно видеть на рисунке \ref{deltablue_i} экспериментально удалось подтвердить, что ускорить конструирование объектов в рамках существующей структуры возможно.

% <<Прямой>> вызов конструкторов

\begin{figure}[ht!]
\centering
	\begin{subfigure}[b]{0.7\textwidth}
	\centering
	\includegraphics[width=\textwidth]{images/deltablue_i_v8.png}
	\caption{Результаты измерений на V8}
    \end{subfigure}

  	\begin{subfigure}[b]{0.7\textwidth}
	\centering
	\includegraphics[width=\textwidth]{images/deltablue_i_mozjs17.png}
	\caption{Результаты измерений на mozjs17}
    \end{subfigure}
\\*``+'' означает что изменения накладываются на предыдущее
\caption{Оптимизация кода сгенерированного на тесте DeltaBlue}
\label{deltablue_i}
\end{figure}

\null
\begin{LARGE}
\begin{center}
\textbf{Выводы}
\end{center}
\end{LARGE}

В результате исследования кода, полученного после компиляции теста DeltaBlue, были сделаны следующие выводы:
\begin{itemize}
\item Необходимоы по-возможности заменить все контейнеры на родные для JavaScript аналоги.
\item Необходимо оптимизировать Kotllin.equals и избигать его вызов когда это возможно.
\end{itemize}


% Инициализировать все поля класса в конструкторе
% Инициализировать все поля класса в одном порядке

\subsection{Havlak}

\null
\begin{LARGE}
\begin{center}
\textbf{Выводы}
\end{center}
\end{LARGE}

В результате исследования кода, полученного после компиляции теста Havlak, были сделаны следующие выводы:

\begin{itemize}
\item hashCode
и контейнеры которые используют hashCode
\item Заменить все контейнеры на родные для JS аналоги
\end{itemize}
\section {Реализация оптимизаций}