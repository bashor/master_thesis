\chapter{Реализация}

\section{Выбор языков для сравнения}
хочется не только понимать что мы улучшились хочется и посмотреть как мы выглядим на фоне остальных

С кем сравниваемся?

JavaScript (бенчмарки от разработчиков v8)
Dart (бенчмарки от разработчиков)
Dart2js

Google Web Toolkit
в паблике тестов производительности нет

Dart -- есть

CoffeeScript и TypeScript нет, во многом это объясняется тем, что эти языки не сильно отличаются от JS ??? у них нету кросс библиотек которые нужно поддерживать на разных платформах. Система типов либо вообще не отличается либо незначительно. Более просетое наследование.

Сравниваться со всем кончено получилось бы и пришлось выбрать нескольких.
Почему именно эти аналоги?
Ну во первых это реализация на чистом JS, были взяты тесты от разработчиков v8. Я считаю это обязательным пунктом, чтобы показать, понять на сколько мы хуже чем код написанный вручную на целевом языке.(тем более экспертами) И сделать выводы в чем мы хуже и почему, что можно улучшить. А в итого показать на сколько мы хуже или лучше чем такой код.

Казалось бы что может быть лучше вручную написанного JS кода? Я решил немного повысить планку и взять Dart, особенность в том, что дарт спроектирован с учетом некоторых недостатков JS, язык разрабоатывается практически той же коммандой которая разрабатывает v8, нативная реализация дарта выполняется в своей виртуальной машине которая знает о коде чуть больше и очень активно пользуется этим, за счет чего на многих тестах уже сейчас показывает лучшие результаты чем вручную написанный JS

Ну и планачка чуть по ниже это js полученный путем трансляции дарт в js

ТО план минимум работать так же хорошо как dart2js, план максимум работать так же хорошо как dart(видимо не всегда достижимый)



\section{Тесты производительности}

Прежде чем начинать пытаться что-то улучшить нужно вырабатать критерии по которым мы сможем проверить на сколько успешными были наши улучшения. А наличие независимых критериев для разных характеристик позволит намнаглядно видить как текйщие изменения влияют на интересуещие нас характеристики. Тем самым, позволив вовремя заметить и отреагировать на ухудшение других характеристик, в результате наших изменений.
В качестве таких критериев обычно выступают тесты производительности. Кроме того, такие тесты могут помочь в поиске <<узких мест>>.

Ни один современный проект по разработке JavaScript виртуальной машины не обходится без тестов производтиельности. В этих проектах в основном используются два типа тестов. Первый тип это так называемые <<микро-бенчмарки>> -- это тесты созданные для измерения отдельных маленьких частей системы. Ярким пример омтаких тестов является набор тестов от разработчиков из Mozilla -- Dromaeo \cite{Dromaeo}  Другой тип используемых тестов, который часто называют <<макро-бенчмарками>> -- это <<реальные>> программы, либо программы имитирующие поведение <<реальных>> программ. Ярыми привереженцами такого похода являются разработчки использующейся в Chrome вритуальной машины V8 \cite{V8:Benchmarks, Octane}. Все эти тесты находятся в открытом доступе и разработчки проверяют результаты свой работы так же и на тестах кокурентов.

В рамках данной работы для реализации тестов производительность было решено взять за основу тесты Richards и DeltaBlue, которые из набора тестов используемого коммандой V8 \cite{V8:Benchmarks}. Так же в значительной мере на выбор повлиял тот факт что данные тесты являются основными в проекте Dart.
Кроме этих двух тестов было решено реализовать тест производительности Havlak, разработанный в компании Google для сравнения таких языков как C++, Java, Go и Scala по таким критериям как: производительность, объем кода, обхем бинарника, объем используемой памяти \cite{Havlak}. Позже разработчики из компании Google так же реализовали данный тест и на многих других языках, например на Dart и JavaScript.
Такой выбор тестов позволил исключить предвзятость при реализации тестов производительности на других языках, т.к. для сравнения с другими языками используются проверенные годами и написанные специалистами тесты. К тому же, все эти тесты находятся в открытом доступе и любой желающий сможет повторить приведенные в данной работе эксперементы.

\subsection{Richards}
Richards
OS kernel simulation benchmark, originally written in BCPL by Martin Richards (539 lines).
Main focus: property load/store, function/method calls
Secondary focus: code optimization, elimination of redundant code

Richards
Данный бенчмар симулирует работу ядра ОС, написан в конце 90х Мартином Ричардсом.
Основной фокс теста -- это чтение и запись данных и вызов функций- методов

OS kernel simulation benchmark, originally written in BCPL by Martin Richards (539 lines).
Main focus: property load/store, function/method calls
Secondary focus: code optimization, elimination of redundant code

---
Richards: Выводы

Оптимизировать доступ к полям/свойствам, по возможности, сохранив бинарную совместимость
Сделать аналог импорта, предоставив тем самым возможность кратко обращаться к объектам и их полям
Необходимо упростить структуру генерируемого кода

\subsection{Deltablue}

Deltablue
constraint solver написанный John Maloney and Mario Wolczko в конце 80х, начале 90х (?)
Основной фокус данного теста -- полиморфизм, ООП стиль программирования. В тесте очень часто и в большем количестве создаются объекты. Эти объекты живут не очень долго и видимо этот тест так же подходит для тестирования GC, но это нас не сильно интересует

One-way constraint solver, originally written in Smalltalk by John Maloney and Mario Wolczko (880 lines).
Main focus: polymorphism
Secondary focus: OO-style programming

---
<<Прямой>> вызов конструкторов
---
DeltaBlue: Выводы

Заменить все контейнеры на родные для JS аналоги
Генерировать чистое прототипное наследование без оберток
Инициализировать все поля класса в конструкторе
Инициализировать все поля класса в одном порядке
Заменить или оптимизировать Kotllin.equals

\subsection{Havlak}

\section{Тестирование и анализ результатов}
\subsection{Методика тестирования}
\subsection{Richards}
\subsection{DeltaBlue}
\subsection{Havlak}
\section {Реализация оптимизаций}